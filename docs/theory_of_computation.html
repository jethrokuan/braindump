<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-28 Tue 16:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Theory Of Computation</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Jethro Kuan" />
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
<script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Theory Of Computation</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgb07df2f">1. Introduction</a>
<ul>
<li><a href="#orgb9615a8">1.1. Formal Proofs</a></li>
<li><a href="#org268492c">1.2. Inductive Proofs</a></li>
<li><a href="#orgc71988e">1.3. Structural Inductions</a></li>
</ul>
</li>
<li><a href="#org181b691">2. Automata Theory</a>
<ul>
<li><a href="#org21f1b90">2.1. Definitions</a></li>
</ul>
</li>
<li><a href="#orgd0cac2b">3. Finite Automata</a>
<ul>
<li><a href="#orgd7682eb">3.1. Deterministic Finite Automata</a>
<ul>
<li><a href="#org2dea2b7">3.1.1. Simpler Notations</a></li>
</ul>
</li>
<li><a href="#org4bc2c44">3.2. Language of a DFA</a></li>
<li><a href="#orgf3293e9">3.3. Extending Transition Function to Strings</a></li>
</ul>
</li>
<li><a href="#org96e2741">4. Nondeterministic Finite Automata</a>
<ul>
<li><a href="#orgfa03e79">4.1. Definition</a></li>
<li><a href="#orge5bc650">4.2. The Language of an NFA</a></li>
<li><a href="#orgf076014">4.3. The Equivalence of DFA and NFA</a></li>
<li><a href="#orge9012e8">4.4. Finite Automata with Epsilon-Transitions</a></li>
<li><a href="#org4f614d0">4.5. Epsilon-Closures</a></li>
<li><a href="#orga0855e6">4.6. Eliminating &epsilon;-Transitions</a></li>
</ul>
</li>
<li><a href="#org0edb414">5. Regular Expressions</a>
<ul>
<li><a href="#org60d2f6b">5.1. Precedence of regular expression operators</a></li>
<li><a href="#orgf0fb408">5.2. Equivalence of DFA and Regular Expressions</a>
<ul>
<li><a href="#org24537d7">5.2.1. From DFA to Regular Expression</a></li>
<li><a href="#orgddb326a">5.2.2. <span class="todo TODO">TODO</span> Converting DFAs to regular expressions by eliminating states</a></li>
<li><a href="#org3a25b88">5.2.3. <span class="todo TODO">TODO</span> Converting regular expressions to automata</a></li>
<li><a href="#orgccdda3d">5.2.4. Algebraic law for regular expressions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgb07df2f" class="outline-2">
<h2 id="orgb07df2f"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Finite automata are a useful model for many kinds of important
software and hardware. Automatas are found in compilers, software for
designing digital circuits, and many more systems.
</p>

<p>
<i>Grammars</i> provide useful models when designing software that processes
data with a recursive structure. The compiler's parser deals with
recursively nested features. Regular Expressions also denote the
structure of data, especially in text strings.
</p>

<p>
The study of automata addresses the following questions:
</p>

<ol class="org-ol">
<li>What can a computer do?</li>
<li>What can a computer do efficiently?</li>
</ol>

<p>
Automata theory also provides a tool for making formal proofs, of both
the inductive and deductive type.
</p>
</div>

<div id="outline-container-orgb9615a8" class="outline-3">
<h3 id="orgb9615a8"><span class="section-number-3">1.1</span> Formal Proofs</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Here the more common proof requirements are here:
</p>

<ol class="org-ol">
<li>Proving set equivalence: we can approach this by rephrasing it into
an iff statement.
<ol class="org-ol">
<li>Prove that if <code>x</code> is in <code>E</code>, then <code>x</code>  is in <code>F</code>.</li>
<li>Prove that if <code>x</code> is in <code>F</code>, then <code>x</code> is in <code>E</code>.</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org268492c" class="outline-3">
<h3 id="org268492c"><span class="section-number-3">1.2</span> Inductive Proofs</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Suppose we are given a statement \(S(n)\) to prove. The inductive
approach involves:
</p>
<ol class="org-ol">
<li>The <i>basis</i>: where we show \(S(i)\) for a particular \(i\).</li>
<li>The <i>inductive step</i>: where we show if \(S(k)\) (or \(S(i), S(i+1),
   \hdots, S(k)\)) then \(S(k+1)\).</li>
</ol>
</div>
</div>

<div id="outline-container-orgc71988e" class="outline-3">
<h3 id="orgc71988e"><span class="section-number-3">1.3</span> Structural Inductions</h3>
<div class="outline-text-3" id="text-1-3">
<p>
We can sometimes prove statements by construction. This is often the
case with recursively defined structures, such as with trees and
expressions. This works because we the recursive definition is invoked
at each step, so we are guaranteed that at each step of the
construction, the construction \(X_i\) is valid.
</p>
</div>
</div>
</div>

<div id="outline-container-org181b691" class="outline-2">
<h2 id="org181b691"><span class="section-number-2">2</span> Automata Theory</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org21f1b90" class="outline-3">
<h3 id="org21f1b90"><span class="section-number-3">2.1</span> Definitions</h3>
<div class="outline-text-3" id="text-2-1">
<dl class="org-dl">
<dt>alphabet</dt><dd>An <i>alphabet</i> is a finite, nonempty set of symbols. E.g.
\(\Sigma = \{0, 1\}\) represents the binary alphabet</dd>
<dt>string</dt><dd>A <i>string</i> is a finite sequence of symbols chosen from some
alphabet. For example, \(01101\) is a string from the binary
alphabet. The empty string is represented by &epsilon;, and
sometimes \(\Lambda\). The
<i>length</i> of a string is denoted as such: \(|001| = 3\)</dd>
<dt>Powers</dt><dd>\(\Sigma^k\) represents strings of length \(k\).</dd>
<dt>Concatenation</dt><dd>\(xy\) denotes the concatenation of strings \(x\) and
\(y\).</dd>
<dt>Problem</dt><dd>a <i>problem</i> is the question of deciding whether a given
string is a member of some particular language.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orgd0cac2b" class="outline-2">
<h2 id="orgd0cac2b"><span class="section-number-2">3</span> Finite Automata</h2>
<div class="outline-text-2" id="text-3">
<p>
An automata has:
</p>
<ul class="org-ul">
<li>a set of states</li>
<li>its "control" moves from state to state in response to external inputs</li>
</ul>

<p>
A finite automata is one where the automaton can only be in a single
state at once (it is deterministic). Non-determinism allows us to
program solutions to problems using a higher-level language.
</p>

<p>
Determinism refers to the fact that on each input there is one and
only one state to which the automaton can transition from its current
state. Deterministic Finite Automata is often abbrieviated with <i>DFA</i>.
</p>
</div>

<div id="outline-container-orgd7682eb" class="outline-3">
<h3 id="orgd7682eb"><span class="section-number-3">3.1</span> Deterministic Finite Automata</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A <i>dfa</i> consists of:
</p>

<ol class="org-ol">
<li>A finite set of <i>states</i>, often denoted \(Q\).</li>
<li>A finite set of <i>input symbols</i>, often denoted \(\Sigma\).</li>
<li>A <i>transition function</i> that takes as arguments a state and an input
symbol and returns a state, often denoted \(\delta\). If \(q\) is a state,
and \(a\) is an input symbol, then \(\delta(q,a)\) is that state \(p\) such
that there is an arc labeled \(a\) from \(q\) to \(p\).</li>
<li>A <i>start state</i>, one of the states in \(Q\).</li>
<li>A set of <i>final</i> or <i>accepting</i> states \(F\). The set \(F\) is a subset of
\(Q\).</li>
</ol>

<p>
In proofs, we often talk about a DFA in "five-tuple" notation:
</p>

\begin{equation}
  A = \left(Q, \Sigma, \delta, q_0, F \right)
\end{equation}
</div>

<div id="outline-container-org2dea2b7" class="outline-4">
<h4 id="org2dea2b7"><span class="section-number-4">3.1.1</span> Simpler Notations</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
The two preferred notation for describing automata are:
</p>
<dl class="org-dl">
<dt>transition diagrams</dt><dd>a graph</dd>
</dl>


<div class="figure">
<p><img src="images/theory_of_computation/Finite Automata/subset-construction-nfa-from-transition-table_2018-08-14_12-47-06.jpg" alt="subset-construction-nfa-from-transition-table_2018-08-14_12-47-06.jpg" />
</p>
</div>

<dl class="org-dl">
<dt>transition table</dt><dd>a tubular listing of the \(\delta\) function, which by
implication tells us the states and the input alphabet.</dd>
</dl>


<div class="figure">
<p><img src="images/theory_of_computation/Finite Automata/jTETt_2018-08-14_12-49-00.png" alt="jTETt_2018-08-14_12-49-00.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org4bc2c44" class="outline-3">
<h3 id="org4bc2c44"><span class="section-number-3">3.2</span> Language of a DFA</h3>
<div class="outline-text-3" id="text-3-2">
<p>
We can define the <i>language</i> of a DFA \(A = \left(Q, \Sigma, q_0, F\right)\).
This language is denoted \(L(A)\), and is defined by:
</p>

\begin{equation}
L(A) = \{ w | \delta(q_0, w) \text{ is in } F\}
\end{equation}

<p>
The language of \(A\) is the set of strings \(w\) that take the start
state \(q_0\) to one of the accepting states.
</p>
</div>
</div>

<div id="outline-container-orgf3293e9" class="outline-3">
<h3 id="orgf3293e9"><span class="section-number-3">3.3</span> Extending Transition Function to Strings</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Basis:
</p>
\begin{equation}
\hat{\delta}\left(q, \epsilon\right) = q
\end{equation}
<p>
Induction:
</p>
\begin{equation}
\hat{\delta}\left(q, xa\right) = \delta \left(\hat{\delta}\left(q, x\right), a \right)
\end{equation}
</div>
</div>
</div>

<div id="outline-container-org96e2741" class="outline-2">
<h2 id="org96e2741"><span class="section-number-2">4</span> Nondeterministic Finite Automata</h2>
<div class="outline-text-2" id="text-4">
<p>
A NFA has can be in several states at once, and this ability is
expressed as an ability to "guess" something about its input. It can
be shown that NFAs accept exactly the regular languages, just as DFAs
do. We can always convert an NFA to a DFA, although the latter may
have exponentially more states than the NFA.
</p>
</div>

<div id="outline-container-orgfa03e79" class="outline-3">
<h3 id="orgfa03e79"><span class="section-number-3">4.1</span> Definition</h3>
<div class="outline-text-3" id="text-4-1">
<p>
An NFA has:
</p>

<ol class="org-ol">
<li>A finite set of states \(Q\).</li>
<li>A finite set of input symbols \(\Sigma\).</li>
<li>A starting state \(q_0 \in Q\),</li>
<li>A set of final states \(F \subset Q\).</li>
<li>A transition function that takes a state in \(Q\) and an input symbol
in \(\Sigma\) as arguments and returns a <b>subset</b> of \(Q\).</li>
</ol>
</div>
</div>

<div id="outline-container-orge5bc650" class="outline-3">
<h3 id="orge5bc650"><span class="section-number-3">4.2</span> The Language of an NFA</h3>
<div class="outline-text-3" id="text-4-2">
<p>
if \(A = (Q, \Sigma, \delta, q_0, F)\) is an NFA, then
</p>

\begin{equation}
L(A) = \{w | \hat{\delta}(q_0, w) \cap F \neq \emptyset\}
\end{equation}

<p>
That is, \(L(A)\) is the set of strings \(w\) in \(\Sigma^*\) such that
\(\hat{\delta}(q_0, w)\).
</p>
</div>
</div>

<div id="outline-container-orgf076014" class="outline-3">
<h3 id="orgf076014"><span class="section-number-3">4.3</span> The Equivalence of DFA and NFA</h3>
<div class="outline-text-3" id="text-4-3">

<div class="figure">
<p><img src="images/theory_of_computation/Nondeterministic Finite Automata/screenshot_2018-08-14_13-44-15.png" alt="screenshot_2018-08-14_13-44-15.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orge9012e8" class="outline-3">
<h3 id="orge9012e8"><span class="section-number-3">4.4</span> Finite Automata with Epsilon-Transitions</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Transitions on &epsilon;, the empty string, allow NFAs to make a transition
spontaneously. This is sometimes referred to as &epsilon;-NFAs, and are
closely related to regular expressions.
</p>


<div class="figure">
<p><img src="images/theory_of_computation/Nondeterministic Finite Automata/screenshot_2018-08-15_11-45-07.png" alt="screenshot_2018-08-15_11-45-07.png" />
</p>
</div>

<p>
Of particular interest is the transition from \(q_0\) to \(q_1\), where the
\(+\) and \(-\) sign is optional.
</p>
</div>
</div>

<div id="outline-container-org4f614d0" class="outline-3">
<h3 id="org4f614d0"><span class="section-number-3">4.5</span> Epsilon-Closures</h3>
<div class="outline-text-3" id="text-4-5">
<p>
We &epsilon;-close a state \(q\) by following all transitions out of \(q\) that
are labelled &epsilon;, eventually finding all states that can be reached
from \(q\) along any path whose arcs are all labelled &epsilon;.
</p>

<p>
&epsilon;-closure allows us to explain easily what the transitions of an
&epsilon;-NFA look like when given a sequence of (non-&epsilon;) inputs. Suppose
that \(E = (Q, \Sigma, \delta, q_0, F)\) is an &epsilon;-NFA. We first define \(\hat{\delta}\),
the extended transition function, to reflect what happens on a
sequence of inputs.
</p>

<p>
<b>BASIS</b>: \(\hat{\delta}(q, \epsilon) = ECLOSE(q)\). If the label of the path is &epsilon;,
then we can follow only &epsilon;-labeled arcs extending from state \(q\).
</p>

<p>
<b>INDUCTION</b>: Suppose \(w\) is of the form \(xa\), where \(a\) is the last
symbol of \(w\). Note that \(a\) is a member of \(\Sigma\); it cannot be &epsilon;.
Then:
</p>

\begin{align}
  \text{Let } & \hat{\delta}(q, x) = \{p_1, p_2, \hdots, p_k\} \\
   & \bigcup\limits_{i=1}^k \delta(p_i, a) = \{r_1, r_2, \hdots, r_m\} \\
  \text{Then } & \hat{\delta}(q,w) = \bigcup\limits_{j=1}^m ECLOSE(r_j)
\end{align}
</div>
</div>

<div id="outline-container-orga0855e6" class="outline-3">
<h3 id="orga0855e6"><span class="section-number-3">4.6</span> Eliminating &epsilon;-Transitions</h3>
<div class="outline-text-3" id="text-4-6">
<p>
Given any &epsilon;-NFA \(E\), we can find a DFA \(D\) that accepts the same
language as \(E\).
</p>

<p>
Let \(E = (Q_E, \Sigma, \delta_E, q_0, F_E)\), then the equivalent DFA \(D = (Q_D, \Sigma,
\delta_D, q_D, F_D)\) is defined as follows:
</p>

<ol class="org-ol">
<li>\(Q_D\) is the set of subsets of \(Q_E\). All accessible states of \(D\)
are &epsilon;-closed subsets of \(Q_E\), i.e. \(S \subseteq Q_K s.t. S =
   ECLOSE(S)\). Any &epsilon;-transition out of one of the states in \(S\)
leads to another state in \(S\).</li>
<li>\(q_D = ECLOSE(q_0)\), we get the start state of \(D\) by closing the set
consisting of only the start state of \(E\).</li>
<li>\(F_D\) is those set of states that contain at least one accepting
state of \(E\). \(F_D = \{S | S \text{ is in } Q_D \text{ and } S \cap F_E
   \neq \emptyset \}\)</li>
<li>\(\delta_D(S,a)\) is computed for all \(a\) in \(\Sigma\) and sets \(S\) in \(Q_D\) by:
<ol class="org-ol">
<li>Let \(S = \{p_1, p_2, \hdots, p_k\}\)</li>
<li>Compute \(\bigcup\limits_{i=1}^{k}\delta_E(p_i, a) = \{r_1, r_2, \hdots, r_m\}\)</li>
<li>Then \(\delta_D(S, a) = \bigcup\limits_{j=1}^{m}ECLOSE(r_j)\)</li>
</ol></li>
</ol>
</div>
</div>
</div>


<div id="outline-container-org0edb414" class="outline-2">
<h2 id="org0edb414"><span class="section-number-2">5</span> Regular Expressions</h2>
<div class="outline-text-2" id="text-5">
<p>
Regular expressions may be thought of as a "programming language", in
which many important applications like text search applications or
compiler components can be expressed in.
</p>

<p>
Regular expressions can define the exact same languages that various
forms of automata describe: the regular languages. Regular expressions
denote languages. We define 3 operations on languages that the
operators of regular expressions represent.
</p>

<ol class="org-ol">
<li>The <i>union</i> of two languages \(L \bigcup M\), is the set of strings
that are either in \(L\) or \(M\).</li>
<li>The <i>concatenation</i> of languages \(L\) and \(M\) is the set of strings
that can be formed by taking any string in \(L\) and concatenating it
with any string in \(M\).</li>
<li>The closure (or star, or <i>Kleene closure</i>) is denoted \(L^*\) and
represents the set of those strings that can be formed by taking
any number of strings from \(L\), possibly with repetitions, and
concatenating all of them.</li>
</ol>

<p>
We can describe regular expressions recursively. For each expression
\(E\), we denote the language it represents with \(L(E)\).
</p>

<p>
<b>BASIS</b>:
</p>

<ol class="org-ol">
<li>The constants \(\epsilon\) and \(\emptyset\) are regular expressions, denoting the
languages \(\{\epsilon\}\) and \(\emptyset\) respectively.</li>
<li>If \(a\) is a symbol, then \(\mathbb{a}\) is a regular expression. This
expression denotes the language \(\{a\}\).</li>
</ol>

<p>
<b>INDUCTION</b>:
</p>

<ol class="org-ol">
<li>\(L(E) + L(F) = L(E) \bigcup L(F)\)</li>
<li>\(L(EF) = L(E)L(F)\)</li>
<li>\(L(E^*) = (L(E))^*\)</li>
<li>\(L((E)) = L(E)\)</li>
</ol>
</div>

<div id="outline-container-org60d2f6b" class="outline-3">
<h3 id="org60d2f6b"><span class="section-number-3">5.1</span> Precedence of regular expression operators</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The precedence in order of highest to lowest, is:
</p>
<ol class="org-ol">
<li>star</li>
<li>dot (note that this operation is associative)</li>
<li>union (\(\plus\) operator)</li>
</ol>
</div>
</div>

<div id="outline-container-orgf0fb408" class="outline-3">
<h3 id="orgf0fb408"><span class="section-number-3">5.2</span> Equivalence of DFA and Regular Expressions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
We show this by showing that:
</p>
<ol class="org-ol">
<li>Every language defined by a DFA is also defined by a regular
expression.</li>
<li>Every language defined by a regular expression is also defined by a
$\epilon$-NFA, which we have already shown is equivalent to a DFA.</li>
</ol>


<div class="figure">
<p><img src="images/theory_of_computation/Regular Expressions/screenshot_2018-08-28_12-46-13.png" alt="screenshot_2018-08-28_12-46-13.png" />
</p>
</div>
</div>

<div id="outline-container-org24537d7" class="outline-4">
<h4 id="org24537d7"><span class="section-number-4">5.2.1</span> From DFA to Regular Expression</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
We can number the finite states in a DFA \(A\) with \(1, 2, \hdots, n\).
</p>

<p>
Let \(R_{ij}^{(k)}\) be the name of a regular expression whose language is the
set of strings \(w\) such that \(w\) is the label of a path from state \(i\)
to state \(j\) in a DFA \(A\), and the path has no intermediate node whose
number is greater than \(k\).
To construct the expression \(R_{ij}^{(k)}\), we use the following inductive
definition, starting at \(k= 0\), and finally reaching \(k=n\).
</p>

<p>
BASIS: \(k=0\).
Since the states are numbered \(1\) or above, the restriction on paths
is that the paths have no intermediate states at all. There are only 2
kinds of paths that meet such a condition:
</p>

<ol class="org-ol">
<li>An arc from node (state) \(i\) to node \(j\).</li>
<li>A path of length \(0\) that consists only of some node \(i\).</li>
</ol>

<p>
If \(i \ne j\), then only case \(1\) is possible. We must examine DFA \(A\)
and find input symbols \(a\) such that there is a transition from state
\(i\) to state \(j\) on symbol \(a\).
</p>

<ol class="org-ol">
<li>If there is no such symbol \(a\), then \(R_{ij}^{(0)} = \emptyset\).</li>
<li>If there is exactly one such symbol \(a\), then \(R_{ij}^{(0)} = \mathbb{a}\)</li>
<li>If there are symbols \(a_1, a_2, \hdots, a_k\) that label arcs from
state \(i\) to state \(j\), then \(R_{ij}^{(0)} = \mathbb{a_1} + \mathbb{a_2} +
   \hdots + \mathbb{a_k}\)</li>
</ol>

<p>
In case (a), the expression becomes \(\epsilon\), in case (c), the expression
becomes \(\epsilon + \mathbb{a_1} + \mathbb{a_2} + \hdots + \mathbb{a_k}\).
</p>

<p>
INDUCTION: Suppose there is a path from state \(i\) to state \(j\) that
goes through no state higher than \(k\). Then either:
</p>

<ol class="org-ol">
<li>The path does not go through state \(k\) at all. In this case, the
label of the path is \(R_{ij}^{(k-1)}\).</li>
<li>The path goes through state \(k\) at least once. We can break the
path into several pieces:</li>
</ol>



<div class="figure">
<p><img src="images/theory_of_computation/Regular Expressions/screenshot_2018-08-28_12-58-35.png" alt="screenshot_2018-08-28_12-58-35.png" />
</p>
</div>

<p>
Then the set of labels for all paths of this type is represented by
the regular expression \(R_{ik}^{(k-1)}(R_{kk}^{(k-1)})^*R_{kj}^{(k-1)}\). Then, we can
combine the expressions for the paths of the two above:
</p>

\begin{equation}
R_{ij}^{(k)} = R_{ik}^{(k-1)}(R_{kk}^{(k-1)})^*R_{kj}^{(k-1)}
\end{equation}

<p>
We can compute \(R_{ij}^{(n)}\) for all \(i\) and \(j\), and the language of the
automaton is then the sum of all expressions \(R_{ij}^{(n)}\) such that state
\(j\) is an accepting state.
</p>
</div>
</div>


<div id="outline-container-orgddb326a" class="outline-4">
<h4 id="orgddb326a"><span class="section-number-4">5.2.2</span> <span class="todo TODO">TODO</span> Converting DFAs to regular expressions by eliminating states</h4>
</div>

<div id="outline-container-org3a25b88" class="outline-4">
<h4 id="org3a25b88"><span class="section-number-4">5.2.3</span> <span class="todo TODO">TODO</span> Converting regular expressions to automata</h4>
</div>

<div id="outline-container-orgccdda3d" class="outline-4">
<h4 id="orgccdda3d"><span class="section-number-4">5.2.4</span> Algebraic law for regular expressions</h4>
<div class="outline-text-4" id="text-5-2-4">
<dl class="org-dl">
<dt>commutativity</dt><dd>\(x + y = y + x\).</dd>
<dt>associativity</dt><dd>\((x \times y) \times z = x \times (y \times z)\).</dd>
<dt>distributive</dt><dd>\(x \times (y + z) = x \times y + x \times z\)</dd>
</dl>
<ul class="org-ul">
<li>\(L + M = M + L\)</li>
<li>\((L + M) + N = L + (M + N)\)</li>
<li>\((LM)N = L(MN)\)</li>
<li>\(\emptyset + L = L + \emptyset = L\). \(\emptyset\) is the identity for union.</li>
<li>\(\epsilon L = L \epsilon = L\). \(\epsilon\) is the identity for concatenation.</li>
<li>\(\emptyset L = L\emptyset = \emptyset\). \(\emptyset\) is the annihilator for concatenation.</li>
<li>\(L(M + N) = LM + LN\) (left distributive)</li>
<li>\((M + N)L  = ML + NL\) (right distributive)</li>
<li>\(L + L = L\) (idempotence law)</li>
<li>\((L^*)^* = L^*\).</li>
<li>\(\emptyset^* = \epsilon\)</li>
<li>\(\epsilon^* = \epsilon\)</li>
<li>\(L^{+} = LL^* = L^*L\).</li>
<li>\(L^* = L^{+} + \epsilon\)</li>
<li>\(L? = \epsilon + L\)</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Jethro Kuan</p>
<p class="date">Created: 2018-08-28 Tue 16:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
