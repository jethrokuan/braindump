#+SETUPFILE: ./export_template.org
#+TITLE: Coding Interview Preparation

* Data Structures Review
  Integers in Python
** TODO How Primitive Types are represented in
1. Python
2. C++

** Primitive Types
Integers in Python 3 are unbounded -- the maximum integer
representable is a function of available memory. The constant
=sys.maxsize= can be used to find the word-size. Bounds on floats are
specified in =sys.float_info=.

**** Bit Manipulation
Computing the parity of a word.
#+BEGIN_SRC python
  def parity(x):
      result = 0
      while x:
          result ^= x & 1
          x >>= 1
      return result
#+END_SRC

=x &= x - 1= Drops the lowest set bit of x. 

The parity of 11011111 is the same as the parity of 1101 XORed with 1111.
#+BEGIN_SRC python
  def parity(x):
      x ^= x >> 32
      x ^= x >> 16
      x ^= x >> 8
      x ^= x >> 4
      x ^= x >> 2
      x ^= x >> 1
      return x & 0x1
#+END_SRC

With time complexity of $O(\log n)$.

**** Swapping Bits
#+BEGIN_SRC python
  def swap_bits(x, i, j):
      if (x >> i) & 1 != (x >> j) & 1: # if ith and jth bits differ
          bit_mask = (1 << i) | (1 << j)
          x ^= bit_mask
      return x
        
#+END_SRC
**** Cheatsheet

| expression | output                           |
|------------+----------------------------------|
| x & x - 1  | clears the lowest set bit of x   |
| x & ~(x-1) | extracts the lowest set bit of x |


** Arrays

Arrays are contiguous blocks of memory, usually used to represent
sequences.

Insertion into a full array can be handled by resizing, allocating a
new array with additional memory and copying over the entries from the
original array.

* Common Questions

** Find kth largest in array
#+BEGIN_SRC python
  import operator

  # The numbering starts from one, i.e., if A = [3, 1, -1, 2]
  # find_kth_largest(1, A) returns 3, find_kth_largest(2, A) returns 2,
  # find_kth_largest(3, A) returns 1, and find_kth_largest(4, A) returns -1.
  def find_kth_largest(k, A):
      def find_kth(comp):
          # Partition A[left:right + 1] around pivot_idx, returns the new index of
          # the pivot, new_pivot_idx, after partition. After partitioning,
          # A[left:new_pivot_idx] contains elements that are "greater than" the
          # pivot, and A[new_pivot_idx + 1:right + 1] contains elements that are
          # "less than" the pivot.
          #
          # Note: "greater than" and "less than" are defined by the comp object.
          #
          # Returns the new index of the pivot element after partition.
          def partition_around_pivot(left, right, pivot_idx):
              pivot_value = A[pivot_idx]
              new_pivot_idx = left
              A[pivot_idx], A[right] = A[right], A[pivot_idx]
              for i in range(left, right):
                  if comp(A[i], pivot_value):
                      A[i], A[new_pivot_idx] = A[new_pivot_idx], A[i]
                      new_pivot_idx += 1
              A[right], A[new_pivot_idx] = A[new_pivot_idx], A[right]
              return new_pivot_idx

          left, right = 0, len(A) - 1
          while left <= right:
              # Generates a random integer in [left, right].
              pivot_idx = random.randint(left, right)
              new_pivot_idx = partition_around_pivot(left, right, pivot_idx)
              if new_pivot_idx == k - 1:
                  return A[new_pivot_idx]
              elif new_pivot_idx > k - 1:
                  right = new_pivot_idx - 1
              else:  # new_pivot_idx < k - 1.
                  left = new_pivot_idx + 1

          raise IndexError('no k-th node in array A')

      return find_kth(operator.gt)
#+END_SRC

#+RESULTS:

** Boyer-Moore String Search Algorithm
The problem is to find a occurrences of string ~p~ in ~t~. The pattern ~p~
is preprocessed, learning from character comparisons to skip pointless
alignments.

1. Try alignments in left-to-right order
2. Try character comparisons in right-to-left order

*Bad character rule*: Upon mismatch, skip alignments until (a) mismatch
becomes a match (b) ~p~ moves past mismatched character

#+BEGIN_SRC text
  T: GCTTCTGCTATCTCTC
  P: CCTTTTGC
         ^ mismatch (right-to-left character comparison)
      ^ earliest C to make mismatch match
         CCTTTTGC
#+END_SRC

*Good suffix rule*: Let ~t~ = matched by inner loop; skip until (a) there
are no mismatches between ~p~ and ~t~, or (b) ~p~ moves past ~t~
