#+SETUPFILE: ./export_template.org
#+TITLE: Coding Interview Preparation

* Data Structures Review
  Integers in Python
** TODO How Primitive Types are represented in
1. Python
2. C++

** Primitive Types
Integers in Python 3 are unbounded -- the maximum integer
representable is a function of available memory. The constant
=sys.maxsize= can be used to find the word-size. Bounds on floats are
specified in =sys.float_info=.

**** Bit Manipulation
Computing the parity of a word.
#+BEGIN_SRC python
  def parity(x):
      result = 0
      while x:
          result ^= x & 1
          x >>= 1
      return result
#+END_SRC

=x &= x - 1= Drops the lowest set bit of x. 

The parity of 11011111 is the same as the parity of 1101 XORed with 1111.
#+BEGIN_SRC python
  def parity(x):
      x ^= x >> 32
      x ^= x >> 16
      x ^= x >> 8
      x ^= x >> 4
      x ^= x >> 2
      x ^= x >> 1
      return x & 0x1
#+END_SRC

With time complexity of $O(\log n)$.

**** Swapping Bits
#+BEGIN_SRC python
  def swap_bits(x, i, j):
      if (x >> i) & 1 != (x >> j) & 1: # if ith and jth bits differ
          bit_mask = (1 << i) | (1 << j)
          x ^= bit_mask
      return x
        
#+END_SRC
**** Cheatsheet

| expression | output                           |
|------------+----------------------------------|
| x & x - 1  | clears the lowest set bit of x   |
| x & ~(x-1) | extracts the lowest set bit of x |


** Arrays

Arrays are contiguous blocks of memory, usually used to represent
sequences.

Insertion into a full array can be handled by resizing, allocating a
new array with additional memory and copying over the entries from the
original array.

** Linked List
#+BEGIN_SRC python
  class ListNode(object):
      def __init__(self, data=0, next_node=None):
          self.data = data
          self.next = next_node
#+END_SRC

#+BEGIN_SRC python
  def search_list(L, key):
      while L and L.data != key:
          L = L.next
      return L
#+END_SRC

#+BEGIN_SRC python
  def insert_after(node, new_node):
      new_node.next = node.next
      node.next = new_node
#+END_SRC

#+BEGIN_SRC python
  def delete_after(node):
      # Need to make sure there is something after to delete
      if node.next:
          node.next = node.next.next
#+END_SRC

* Common Questions

** Find kth largest in array
#+BEGIN_SRC python
  import operator

  # The numbering starts from one, i.e., if A = [3, 1, -1, 2]
  # find_kth_largest(1, A) returns 3, find_kth_largest(2, A) returns 2,
  # find_kth_largest(3, A) returns 1, and find_kth_largest(4, A) returns -1.
  def find_kth_largest(k, A):
      def find_kth(comp):
          # Partition A[left:right + 1] around pivot_idx, returns the new index of
          # the pivot, new_pivot_idx, after partition. After partitioning,
          # A[left:new_pivot_idx] contains elements that are "greater than" the
          # pivot, and A[new_pivot_idx + 1:right + 1] contains elements that are
          # "less than" the pivot.
          #
          # Note: "greater than" and "less than" are defined by the comp object.
          #
          # Returns the new index of the pivot element after partition.
          def partition_around_pivot(left, right, pivot_idx):
              pivot_value = A[pivot_idx]
              new_pivot_idx = left
              A[pivot_idx], A[right] = A[right], A[pivot_idx]
              for i in range(left, right):
                  if comp(A[i], pivot_value):
                      A[i], A[new_pivot_idx] = A[new_pivot_idx], A[i]
                      new_pivot_idx += 1
              A[right], A[new_pivot_idx] = A[new_pivot_idx], A[right]
              return new_pivot_idx

          left, right = 0, len(A) - 1
          while left <= right:
              # Generates a random integer in [left, right].
              pivot_idx = random.randint(left, right)
              new_pivot_idx = partition_around_pivot(left, right, pivot_idx)
              if new_pivot_idx == k - 1:
                  return A[new_pivot_idx]
              elif new_pivot_idx > k - 1:
                  right = new_pivot_idx - 1
              else:  # new_pivot_idx < k - 1.
                  left = new_pivot_idx + 1

          raise IndexError('no k-th node in array A')

      return find_kth(operator.gt)
#+END_SRC

#+RESULTS:

** Boyer-Moore String Search Algorithm
The problem is to find a occurrences of string ~p~ in ~t~. The pattern ~p~
is preprocessed, learning from character comparisons to skip pointless
alignments.

1. Try alignments in left-to-right order
2. Try character comparisons in right-to-left order

*Bad character rule*: Upon mismatch, skip alignments until (a) mismatch
becomes a match (b) ~p~ moves past mismatched character

#+BEGIN_SRC text
  T: GCTTCTGCTATCTCTC
  P: CCTTTTGC
         ^ mismatch (right-to-left character comparison)
      ^ earliest C to make mismatch match
         CCTTTTGC
#+END_SRC

*Good suffix rule*: Let ~t~ = matched by inner loop; skip until (a) there
are no mismatches between ~p~ and ~t~, or (b) ~p~ moves past ~t~

Another linear-time string search algorithm is the [[https://en.wikipedia.org/wiki/Rabin%25E2%2580%2593Karp_algorithm][Rabin-Karp
algorithm]], which uses a rolling hash.

** Delete Duplicates in Linked List
#+BEGIN_SRC python
  def deleteDuplicates(A):
      head = A
      while A:
          while A.next and A.next.val == A.val:
              A.next = A.next.next
          A = A.next
      return head
#+END_SRC

** Longest Increasing Subsequence (LIS)

$O(n^2)$ solution involves dynamic programming. Let $L[i]$ be the
length of the LIS ending at index $i$, such that $arr[i]$ is the last
element of the LIS.

Then $L(i) = 1 + max(L[j])$ where $0 < j < i$ and $arr[j] < arr[i]$ or
$L[i] = 1$ if no such $j$ exists.

#+BEGIN_SRC python
  def longest_increasing_subsequence(arr):
      l = len(arr)
      # Initialize LIS
      lis = [1] * l

      for i in range(1, l):
          for j in range(0, i):
              if arr[i] > arr[j]:
                  lis[i] = max(lis[i], lis[j] + 1)

      return max(lis)
#+END_SRC

** Generating a Random Sample
#+BEGIN_SRC python
  import random

  def random_sample(k, A):
      """Generates a rondom subset of size k from array A."""
      for i in range(k):
          r = random.randint(i, len(A)-1)
          A[i], A[r] = A[r], A[i]
      return A[:k]
#+END_SRC

** Generate a random sample from a stream

The basic idea is that given the ~n+1~ element, and a random subset of
size ~k~, where ~k<n~, then that element should belong to that new subset
with probability ~k/(n+1)~.

#+BEGIN_SRC python
  import random

  def online_random_sample(it, A):
      # Stores the first k elements
      sampling_results = list(itertools.islice(it, k))

      num_seen_so_far = k
      for x in it:
          num_seen_so_far += 1
          idx_to_replace = random.randrange(num_seen_so_far)
          if idx_to_replace < k:
              sampling_results[idx_to_replace] = x

      return sampling_results
#+END_SRC

** Checking sub-sequence
#+BEGIN_SRC python :results output
  def is_subsequence(st, seq):
      it = iter(st)
      return all(c in it for c in seq)

  print(is_subsequence("hello", "el"))
  print(is_subsequence("hello", "no"))
#+END_SRC

#+RESULTS:
: True
: False
